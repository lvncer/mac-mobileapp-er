# テーブル設計の根拠とリレーションシップ分析

## 1. 店舗営業時間を別テーブル（STORE_HOURS）に分けた理由

### 正規化の観点

- 元の設計では「営業時間（店内、ドライブスルー、朝マック、モバイルオーダー）」が 1 つの属性に複数の値を格納
- 1 つのセルに複数の値が入ることは 1NF に違反

### 具体的な問題点

```md
元の設計（問題のある例）：
STORES テーブル

- store_id: 1
- operating_hours: "店内:6:00-24:00,ドライブスルー:5:00-25:00,朝マック:5:00-10:30"
```

### 解決後の設計

```md
STORES テーブル

- store_id: 1
- store_name: "マクドナルド新宿店"

STORE_HOURS テーブル

- store_hour_id: 1, store_id: 1, service_type: "店内", open_time: "06:00", close_time: "24:00", day_of_week: "平日"
- store_hour_id: 2, store_id: 1, service_type: "ドライブスルー", open_time: "05:00", close_time: "25:00", day_of_week: "平日"
- store_hour_id: 3, store_id: 1, service_type: "朝マック", open_time: "05:00", close_time: "10:30", day_of_week: "平日"
```

### メリット

1. **柔軟性**: サービスタイプごとに異なる営業時間を設定可能
2. **拡張性**: 新しいサービスタイプ（モバイルオーダー、配送など）を容易に追加
3. **曜日対応**: 平日・土日で異なる営業時間を設定可能
4. **検索性**: 特定のサービスタイプや時間帯での検索が効率的
5. **保守性**: 営業時間の変更が容易

## 2. コアテーブル間のリレーションシップ分析

### 1 対多（1:N）のリレーション

#### MEMBERS（会員） → ORDERS（注文） [1:N]

```md
関係: 1 人の会員は複数の注文を行える
実装: ORDERS テーブルに member_id FK
例: 会員 ID=1 の田中さんが複数回注文
```

#### STORES（店舗） → ORDERS（注文） [1:N]

```md
関係: 1 つの店舗は複数の注文を受ける
実装: ORDERS テーブルに store_id FK
例: 新宿店で複数の顧客からの注文を受ける
```

#### MENUS（メニュー） → ORDER_DETAILS（注文詳細） [1:N]

```md
関係: 1 つのメニューは複数の注文で使用される
実装: ORDER_DETAILS テーブルに menu_id FK
例: ビッグマックが複数の注文で注文される
```

#### ORDERS（注文） → ORDER_DETAILS（注文詳細） [1:N]

```md
関係: 1 つの注文には複数の商品が含まれる
実装: ORDER_DETAILS テーブルに order_id FK
例: 1 つの注文でビッグマック、ポテト、コーラを注文
```

### 多対多（N:N）のリレーション

#### MEMBERS（会員） ↔ STORES（店舗） [N:N]

```md
関係: 会員は複数の店舗をお気に入りにでき、店舗は複数の会員にお気に入りされる
実装: FAVORITE_STORES テーブル（中間テーブル）

- member_id FK
- store_id FK
  例: 田中さんが新宿店と渋谷店をお気に入りに登録
```

#### COUPONS（クーポン） ↔ STORES（店舗） [N:N]

```md
関係: 1 つのクーポンは複数の店舗で使用でき、1 つの店舗は複数のクーポンを受け付ける
実装: COUPON_STORES テーブル（中間テーブル）

- coupon_id FK
- store_id FK
  例: "ビッグマック 100 円引き"クーポンが複数店舗で利用可能
```

#### COUPONS（クーポン） ↔ MENUS（メニュー） [N:N]

```md
関係: 1 つのクーポンは複数のメニューに適用でき、1 つのメニューは複数のクーポンの対象になる
実装: COUPON_MENUS テーブル（中間テーブル）

- coupon_id FK
- menu_id FK
  例: "バーガー類 20%OFF"クーポンが複数のバーガーメニューに適用
```

### 1 対 1（1:1）のリレーション

#### ORDERS（注文） → PAYMENTS（決済） [1:1]

```md
関係: 1 つの注文には 1 つの決済情報が対応
実装: PAYMENTS テーブルに order_id FK（UNIQUE 制約）
例: 注文 ID=123 の注文に対して、決済 ID=456 の決済情報が 1 つだけ存在
```

## 3. リレーションシップの設計判断基準

### 1 対多を選択する理由

- 親エンティティの 1 つのレコードに対して、子エンティティの複数レコードが関連する場合
- 外部キーで十分に関係を表現できる場合

### 多対多を選択する理由

- 両方のエンティティが互いに複数の関係を持つ場合
- 中間テーブルで追加情報（作成日時など）を管理したい場合

### 1 対 1 を選択する理由

- セキュリティ上分離したい情報がある場合
- パフォーマンス上、頻繁にアクセスされない情報を分離したい場合
- 決済情報のように、注文と密接に関連するが独立した情報の場合

## 4. 設計の利点

### データ整合性

- 外部キー制約により参照整合性が保証される
- 中間テーブルにより複雑な関係も正確に表現

### 拡張性

- 新しいサービスタイプ、クーポン種別の追加が容易
- 営業時間の複雑化（祝日対応など）にも対応可能

### パフォーマンス

- 適切な正規化により冗長性を排除
- インデックス設計により効率的な検索が可能
